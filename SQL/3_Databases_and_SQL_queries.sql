
============================================
/*3.1 База данных «Тестирование», запросы на выборку*/
============================================

/*Вывести студентов, которые сдавали дисциплину «Основы баз данных», указать дату попытки и результат. 
Информацию вывести по убыванию результатов тестирования.*/
SELECT name_student, date_attempt, result
FROM attempt
    INNER JOIN student USING(student_id)
    INNER JOIN subject USING(subject_id)
WHERE subject_id = 2
ORDER BY result DESC;
+-----------------+--------------+--------+
| name_student    | date_attempt | result |
+-----------------+--------------+--------+
| Яковлева Галина | 2020-04-21   | 100    |
| Баранов Павел   | 2020-03-23   | 67     |
| Яковлева Галина | 2020-03-26   | 0      |
+-----------------+--------------+--------+

/*Вывести, сколько попыток сделали студенты по каждой дисциплине, а также средний результат попыток, который 
округлить до 2 знаков после запятой. Под результатом попытки понимается процент правильных ответов на вопросы 
теста, который занесен в столбец result.  В результат включить название дисциплины, а также вычисляемые столбцы 
Количество и Среднее. Информацию вывести по убыванию средних результатов.*/
SELECT name_subject, COUNT(result) AS Количество, ROUND(AVG(attempt.result),2) AS Среднее
FROM attempt
    RIGHT JOIN subject USING(subject_id)
GROUP BY name_subject
ORDER BY Среднее DESC;
+-------------------+------------+---------+
| name_subject      | Количество | Среднее |
+-------------------+------------+---------+
| Основы SQL        | 4          | 58.25   |
| Основы баз данных | 3          | 55.67   |
| Физика            | 0          | NULL    |
+-------------------+------------+---------+

/*Вывести студентов (различных студентов), имеющих максимальные результаты попыток. Информацию отсортировать в 
алфавитном порядке по фамилии студента.*/
SELECT name_student, attempt.result
FROM attempt
    INNER JOIN student USING(student_id)
WHERE result = (
    SELECT MAX(result)
    FROM attempt)
ORDER BY name_student;
+-----------------+--------+
| name_student    | result |
+-----------------+--------+
| Семенов Иван    | 100    |
| Яковлева Галина | 100    |
+-----------------+--------+

/*Если студент совершал несколько попыток по одной и той же дисциплине, то вывести разницу в днях между первой и 
последней попыткой. В результат включить фамилию и имя студента, название дисциплины и вычисляемый столбец Интервал.
Информацию вывести по возрастанию разницы. Студентов, сделавших одну попытку по дисциплине, не учитывать. */
SELECT name_student, name_subject, DATEDIFF(MAX(date_attempt), MIN(date_attempt)) AS Интервал
FROM attempt
    INNER JOIN student USING(student_id)
    INNER JOIN subject USING(subject_id)
WHERE attempt.student_id > 1 AND attempt.subject_id = subject.subject_id
GROUP BY name_student, name_subject
ORDER BY Интервал;
+-----------------+-------------------+----------+
| name_student    | name_subject      | Интервал |
+-----------------+-------------------+----------+
| Яковлева Галина | Основы баз данных | 26       |
| Семенов Иван    | Основы SQL        | 55       |
+-----------------+-------------------+----------+

/*Студенты могут тестироваться по одной или нескольким дисциплинам (не обязательно по всем). Вывести дисциплину и количество
уникальных студентов (столбец назвать Количество), которые по ней проходили тестирование . Информацию отсортировать сначала
по убыванию количества, а потом по названию дисциплины. В результат включить и дисциплины, тестирование по которым студенты
еще не проходили, в этом случае указать количество студентов 0.*/
SELECT name_subject, COUNT(DISTINCT(attempt.student_id)) AS Количество
FROM attempt
    RIGHT JOIN subject USING(subject_id)
GROUP BY name_subject
ORDER BY Количество DESC, name_subject;
+-------------------+------------+
| name_subject      | Количество |
+-------------------+------------+
| Основы SQL        | 2          |
| Основы баз данных | 2          |
| Физика            | 0          |
+-------------------+------------+

/*Случайным образом отберите 3 вопроса по дисциплине «Основы баз данных». В результат включите столбцы question_id и name_question.*/
SELECT question_id, name_question
FROM question
    INNER JOIN subject USING(subject_id)
WHERE subject.name_subject = 'Основы баз данных'
ORDER BY RAND()
LIMIT 3;
+-------------+----------------------------------------+
| question_id | name_question                          |
+-------------+----------------------------------------+
| 7           | Отношение - это:                       |
| 6           | База данных - это:                     |
| 8           | Концептуальная модель используется для |
+-------------+----------------------------------------+

/*Вывести вопросы, которые были включены в тест для Семенова Ивана по дисциплине «Основы SQL» 2020-05-17  (значение attempt_id
для этой попытки равно 7). Указать, какой ответ дал студент и правильный он или нет (вывести Верно или Неверно). В результат 
включить вопрос, ответ и вычисляемый столбец  Результат.*/
SELECT name_question, answer.name_answer, IF(answer.is_correct = TRUE,'Верно','Неверно') AS Результат
FROM testing
    INNER JOIN question ON testing.question_id = question.question_id
    INNER JOIN answer ON answer.answer_id = testing.answer_id
WHERE testing.attempt_id = 7;
+----------------------------------------------------------+-----------------------+-----------+
| name_question                                            | name_answer           | Результат |
+----------------------------------------------------------+-----------------------+-----------+
| Запрос на выборку начинается с ключевого слова:          | INSERT                | Неверно   |
| Какой запрос выбирает все записи из таблицы student:     | SELECT * FROM student | Верно     |
| Для внутреннего соединения таблиц используется оператор: | CROSS JOIN            | Неверно   |
+----------------------------------------------------------+-----------------------+-----------+

/*Посчитать результаты тестирования. Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество
вопросов в каждой попытке) и умноженное на 100. Результат округлить до двух знаков после запятой. Вывести фамилию студента,
название предмета, дату и результат. Последний столбец назвать Результат. Информацию отсортировать сначала по фамилии студента,
потом по убыванию даты попытки.*/
SELECT name_student, name_subject, date_attempt,  ROUND(SUM(is_correct)*100/3, 2) AS Результат
FROM attempt
    INNER JOIN student ON attempt.student_id = student.student_id
    INNER JOIN subject ON subject.subject_id = attempt.subject_id
    INNER JOIN testing ON testing.attempt_id = attempt.attempt_id
    INNER JOIN answer ON answer.answer_id = testing.answer_id
GROUP BY name_student, name_subject, date_attempt
ORDER BY name_student, date_attempt DESC;
+-----------------+-------------------+--------------+-----------+
| name_student    | name_subject      | date_attempt | Результат |
+-----------------+-------------------+--------------+-----------+
| Баранов Павел   | Основы SQL        | 2020-04-15   | 33.33     |
| Баранов Павел   | Основы баз данных | 2020-03-23   | 66.67     |
| Семенов Иван    | Основы SQL        | 2020-05-17   | 33.33     |
| Семенов Иван    | Основы SQL        | 2020-04-15   | 66.67     |
| Семенов Иван    | Основы SQL        | 2020-03-23   | 100.00    |
| Яковлева Галина | Основы баз данных | 2020-04-21   | 100.00    |
| Яковлева Галина | Основы баз данных | 2020-03-26   | 0.00      |
+-----------------+-------------------+--------------+-----------+

/*Для каждого вопроса вывести процент успешных решений, то есть отношение количества верных ответов к общему количеству 
ответов, значение округлить до 2-х знаков после запятой. Также вывести название предмета, к которому относится вопрос, и
 общее количество ответов на этот вопрос. В результат включить название дисциплины, вопросы по ней (столбец назвать Вопрос),
а также два вычисляемых столбца Всего_ответов и Успешность. Информацию отсортировать сначала по названию дисциплины, потом по
 убыванию успешности, а потом по тексту вопроса в алфавитном порядке.*/
SELECT name_subject, CONCAT(LEFT(name_question, 30), '...') AS Вопрос, COUNT(is_correct) AS Всего_ответов, ROUND(SUM(is_correct) / COUNT(is_correct)*100, 2) AS Успешность 
FROM attempt
    INNER JOIN student ON attempt.student_id = student.student_id
    INNER JOIN subject ON subject.subject_id = attempt.subject_id
    INNER JOIN testing ON testing.attempt_id = attempt.attempt_id
    INNER JOIN answer ON answer.answer_id = testing.answer_id
    INNER JOIN question ON question.question_id = answer.question_id
GROUP BY name_subject, Вопрос
ORDER BY name_subject, Успешность DESC, Вопрос;
+-------------------+-----------------------------------+---------------+------------+
| name_subject      | Вопрос                            | Всего_ответов | Успешность |
+-------------------+-----------------------------------+---------------+------------+
| Основы SQL        | Условие, по которому отбираютс... | 1             | 100.00     |
| Основы SQL        | Запрос на выборку начинается с... | 4             | 75.00      |
| Основы SQL        | Какой запрос выбирает все запи... | 3             | 66.67      |
| Основы SQL        | Для сортировки используется:...   | 2             | 50.00      |
| Основы SQL        | Для внутреннего соединения таб... | 2             | 0.00       |
| Основы баз данных | База данных - это:...             | 3             | 66.67      |
| Основы баз данных | Какой тип данных не допустим в... | 2             | 50.00      |
| Основы баз данных | Концептуальная модель использу... | 2             | 50.00      |
| Основы баз данных | Отношение - это:...               | 2             | 50.00      |
+-------------------+-----------------------------------+---------------+------------+

/*Придумайте один или несколько запросов на выборку
Вывести количество ответов и среднюю успешность (процент правильных ответов) по каждому студенту. Отсортировать по средней успешности по убыванию.*/
SELECT name_student, IF (COUNT(attempt.attempt_id) > 0, round(SUM(answer.is_correct) / COUNT(testing.testing_id) * 100, 2), 0) AS Правильных_ответов
FROM student
      LEFT JOIN attempt ON attempt.student_id = student.student_id
      LEFT JOIN testing ON testing.attempt_id = attempt.attempt_id
      LEFT JOIN answer ON answer.answer_id = testing.answer_id
GROUP BY student.student_id
ORDER BY Правильных_ответов DESC;
+-----------------+--------------------+
| name_student    | Правильных_ответов |
+-----------------+--------------------+
| Семенов Иван    | 66.67              |
| Баранов Павел   | 50.00              |
| Яковлева Галина | 50.00              |
| Абрамова Катя   | 0                  |
+-----------------+--------------------+

=========================================================
/*3.2 База данных «Тестирование», запросы корректировки*/
=========================================================

/*В таблицу attempt включить новую попытку для студента Баранова Павла по дисциплине «Основы баз данных». Установить
 текущую дату в качестве даты выполнения попытки.*/
INSERT INTO attempt (student_id, subject_id, date_attempt, result)
SELECT 
    (SELECT student_id FROM student WHERE name_student = 'Баранов Павел'),
    (SELECT subject_id FROM subject WHERE name_subject = 'Основы баз данных'),
    NOW(),
    Null;

SELECT * FROM attempt;
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2022-06-25   | NULL   |
+------------+------------+------------+--------------+--------+

/*Случайным образом выбрать три вопроса (запрос) по дисциплине, тестирование по которой собирается проходить студент, 
занесенный в таблицу attempt последним, и добавить их в таблицу testing. id последней попытки получить как максимальное
 значение id из таблицы attempt.*/
INSERT INTO testing (attempt_id, question_id)
SELECT attempt_id, question_id
FROM attempt
    INNER JOIN question ON attempt.subject_id = question.subject_id
WHERE attempt_id = (SELECT MAX(attempt_id) FROM attempt) 
ORDER BY RAND()
LIMIT 3;

Select * FROM testing;

/*Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат
(запрос) и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных
 ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.
Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 8.*/
UPDATE attempt 
SET result = (SELECT ROUND(SUM(is_correct)*100/3) AS Результат
FROM testing 
    INNER JOIN answer ON answer.answer_id = testing.answer_id
    WHERE attempt_id = 8)
WHERE attempt_id = 8;
              
SELECT * FROM attempt;
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2020-06-12   | 67     |
+------------+------------+------------+--------------+--------+

/*Удалить из таблицы attempt все попытки, выполненные раньше 1 мая 2020 года. Также удалить и все соответствующие этим 
попыткам вопросы из таблицы testing, которая создавалась следующим запросом:*/
DELETE FROM attempt, testing
USING 
    attempt 
    INNER JOIN testing ON testing.attempt_id = attempt.attempt_id
WHERE attempt.date_attempt < '2020-05-01';

SELECT * FROM attempt;
SELECT * FROM testing;
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2020-06-12   | 67     |
+------------+------------+------------+--------------+--------+
Affected rows: 2

Query result:
+------------+------------+-------------+-----------+
| testing_id | attempt_id | question_id | answer_id |
+------------+------------+-------------+-----------+
| 19         | 7          | 1           | 3         |
| 20         | 7          | 4           | 11        |
| 21         | 7          | 5           | 16        |
| 22         | 8          | 7           | 19        |
| 23         | 8          | 6           | 17        |
| 24         | 8          | 8           | 22        |
+------------+------------+-------------+-----------+

/*Придумайте один или несколько запросов корректировки данных
Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат
(запрос) и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных
 ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.
Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 5.*/
UPDATE attempt 
SET result = (SELECT ROUND(SUM(is_correct)*100/3)
FROM answer
    INNER JOIN testing ON answer.answer_id = testing.answer_id
    WHERE attempt_id = 5)
WHERE attempt_id = 5;

SELECT * FROM attempt;
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
+------------+------------+------------+--------------+--------+

=====================================================
/*3.3 База данных «Абитуриент», запросы на выборку*/
=====================================================

/*Вывести абитуриентов, которые хотят поступать на образовательную программу «Мехатроника и робототехника» в 
отсортированном по фамилиям виде.*/
SELECT name_enrollee
FROM program
    INNER JOIN program_enrollee ON program_enrollee.program_id = program.program_id
    INNER JOIN enrollee ON enrollee.enrollee_id = program_enrollee.enrollee_id
WHERE program.name_program = 'Мехатроника и робототехника'
ORDER BY name_enrollee;
+-----------------+
| name_enrollee   |
+-----------------+
| Баранов Павел   |
| Попов Илья      |
| Семенов Иван    |
| Степанова Дарья |
+-----------------+

/*Вывести образовательные программы, на которые для поступления необходим предмет «Информатика». Программы отсортировать
 в обратном алфавитном порядке.*/
SELECT name_program
FROM program
    INNER JOIN program_subject ON program_subject.program_id = program.program_id
    INNER JOIN subject ON subject.subject_id = program_subject.subject_id
WHERE subject.name_subject = 'Информатика'
ORDER BY name_program DESC;
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Прикладная математика и информатика |
| Математика и компьютерные науки     |
+-------------------------------------+

/*Выведите количество абитуриентов, сдавших ЕГЭ по каждому предмету, максимальное, минимальное и среднее значение баллов
по предмету ЕГЭ. Вычисляемые столбцы назвать Количество, Максимум, Минимум, Среднее. Информацию отсортировать по названию
предмета в алфавитном порядке, среднее значение округлить до одного знака после запятой.*/
SELECT name_subject, 
    COUNT(result) AS Количество, 
    MAX(result) AS Максимум,
    MIN(result) AS Минимум,
    ROUND(AVG(result), 1) AS Среднее
FROM enrollee_subject
    INNER JOIN subject ON subject.subject_id = enrollee_subject.subject_id
GROUP BY name_subject
ORDER BY name_subject;
+--------------+------------+----------+---------+---------+
| name_subject | Количество | Максимум | Минимум | Среднее |
+--------------+------------+----------+---------+---------+
| Информатика  | 4          | 94       | 75      | 82.0    |
| Математика   | 6          | 92       | 67      | 75.3    |
| Русский язык | 6          | 90       | 65      | 77.5    |
| Физика       | 5          | 90       | 41      | 69.8    |
+--------------+------------+----------+---------+---------+

/*Вывести образовательные программы, для которых минимальный балл ЕГЭ по каждому предмету больше или равен 40 баллам.
Программы вывести в отсортированном по алфавиту виде.*/
SELECT name_program
FROM program
    INNER JOIN program_subject ON program_subject.program_id = program.program_id
GROUP BY name_program
HAVING MIN(min_result) >= 40
ORDER BY name_program;
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Мехатроника и робототехника         |
| Прикладная математика и информатика |
+-------------------------------------+

/*Вывести образовательные программы, которые имеют самый большой план набора,  вместе с этой величиной.*/
SELECT name_program, plan
FROM program
WHERE plan = (SELECT MAX(plan) FROM program);
+-----------------------------+------+
| name_program                | plan |
+-----------------------------+------+
| Мехатроника и робототехника | 3    |
+-----------------------------+------+

/*Посчитать, сколько дополнительных баллов получит каждый абитуриент. Столбец с дополнительными баллами назвать Бонус.
Информацию вывести в отсортированном по фамилиям виде.*/
SELECT name_enrollee, IF(SUM(bonus) IS Null, 0, SUM(bonus)) AS Бонус
FROM enrollee
    LEFT JOIN enrollee_achievement ON enrollee_achievement.enrollee_id = enrollee.enrollee_id
    LEFT JOIN achievement ON achievement.achievement_id = enrollee_achievement.achievement_id
GROUP BY name_enrollee
ORDER BY name_enrollee;
+-----------------+-------+
| name_enrollee   | Бонус |
+-----------------+-------+
| Абрамова Катя   | 0     |
| Баранов Павел   | 6     |
| Попов Илья      | 8     |
| Семенов Иван    | 5     |
| Степанова Дарья | 0     |
| Яковлева Галина | 1     |
+-----------------+-------+

/*Выведите сколько человек подало заявление на каждую образовательную программу и конкурс на нее (число поданных заявлений деленное на количество мест по плану), округленный до 2-х знаков после запятой. В запросе вывести название факультета, к которому относится образовательная программа, название образовательной программы, план набора абитуриентов на образовательную программу (plan), количество поданных заявлений (Количество) и Конкурс. Информацию отсортировать в порядке убывания конкурса.*/
SELECT name_department, name_program, plan, COUNT(enrollee_id) AS Количество, ROUND(COUNT(enrollee_id) / plan, 2) AS Конкурс
FROM program
    INNER JOIN program_enrollee ON program_enrollee.program_id = program.program_id
    INNER JOIN department ON program.department_id = department.department_id
GROUP BY name_department, name_program, plan
ORDER BY Конкурс DESC;
+-------------------------+-------------------------------------+------+------------+---------+
| name_department         | name_program                        | plan | Количество | Конкурс |
+-------------------------+-------------------------------------+------+------------+---------+
| Школа естественных наук | Математика и компьютерные науки     | 1    | 3          | 3.00    |
| Инженерная школа        | Прикладная механика                 | 2    | 4          | 2.00    |
| Школа естественных наук | Прикладная математика и информатика | 2    | 3          | 1.50    |
| Инженерная школа        | Мехатроника и робототехника         | 3    | 4          | 1.33    |
+-------------------------+-------------------------------------+------+------------+---------+

/*Вывести образовательные программы, на которые для поступления необходимы предмет «Информатика» и «Математика» в 
отсортированном по названию программ виде.*/
SELECT name_program
FROM program
WHERE name_program LIKE '%Математика%' OR name_program LIKE '%Информатика%'
GROUP BY name_program
ORDER BY name_program;
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Математика и компьютерные науки     |
| Прикладная математика и информатика |
+-------------------------------------+

/*Посчитать количество баллов каждого абитуриента на каждую образовательную программу, на которую он подал заявление, 
по результатам ЕГЭ. В результат включить название образовательной программы, фамилию и имя абитуриента, а также столбец 
с суммой баллов, который назвать itog. Информацию вывести в отсортированном сначала по образовательной программе, а потом 
по убыванию суммы баллов виде.*/
SELECT name_program, name_enrollee, SUM(result) AS itog
FROM enrollee
    INNER JOIN program_enrollee ON program_enrollee.enrollee_id = enrollee.enrollee_id
    INNER JOIN program ON program.program_id = program_enrollee.program_id
    INNER JOIN program_subject ON program_subject.program_id = program.program_id
    INNER JOIN subject ON subject.subject_id = program_subject.subject_id
    INNER JOIN enrollee_subject ON enrollee_subject.subject_id = subject.subject_id
    and enrollee_subject.enrollee_id = enrollee.enrollee_id
GROUP BY name_program, name_enrollee
ORDER BY name_program, itog DESC;
+-------------------------------------+-----------------+------+
| name_program                        | name_enrollee   | itog |
+-------------------------------------+-----------------+------+
| Математика и компьютерные науки     | Степанова Дарья | 276  |
| Математика и компьютерные науки     | Семенов Иван    | 230  |
| Математика и компьютерные науки     | Абрамова Катя   | 226  |
| Мехатроника и робототехника         | Степанова Дарья | 270  |
| Мехатроника и робототехника         | Семенов Иван    | 242  |
| Мехатроника и робототехника         | Попов Илья      | 192  |
| Мехатроника и робототехника         | Баранов Павел   | 179  |
| Прикладная математика и информатика | Семенов Иван    | 230  |
| Прикладная математика и информатика | Абрамова Катя   | 226  |
| Прикладная математика и информатика | Баранов Павел   | 213  |
| Прикладная механика                 | Степанова Дарья | 270  |
| Прикладная механика                 | Яковлева Галина | 238  |
| Прикладная механика                 | Попов Илья      | 192  |
| Прикладная механика                 | Баранов Павел   | 179  |
+-------------------------------------+-----------------+------+

/*Вывести название образовательной программы и фамилию тех абитуриентов, которые подавали документы на эту образовательную
 программу, но не могут быть зачислены на нее. Эти абитуриенты имеют результат по одному или нескольким предметам ЕГЭ, 
 необходимым для поступления на эту образовательную программу, меньше минимального балла. Информацию вывести в отсортированном
  сначала по программам, а потом по фамилиям абитуриентов виде.*/
SELECT name_program, name_enrollee
FROM enrollee
    INNER JOIN program_enrollee ON program_enrollee.enrollee_id = enrollee.enrollee_id
    INNER JOIN program ON program.program_id = program_enrollee.program_id
    INNER JOIN program_subject ON program_subject.program_id = program.program_id
    INNER JOIN subject ON subject.subject_id = program_subject.subject_id
    INNER JOIN enrollee_subject ON enrollee_subject.subject_id = subject.subject_id
    and enrollee_subject.enrollee_id = enrollee.enrollee_id
WHERE result < min_result
ORDER BY name_program, name_enrollee;
+-----------------------------+---------------+
| name_program                | name_enrollee |
+-----------------------------+---------------+
| Мехатроника и робототехника | Баранов Павел |
| Прикладная механика         | Баранов Павел |
+-----------------------------+---------------+

/*Придумайте один или несколько запросов на выборку для предметной области «Абитуриент»
Выбрать программы с минимальным конкурсом. Для этого составить список программ с указанием проходного балла и конкурса. Отсортировать по конкурсу.*/
SELECT name_program,
    SUM(min_result) AS Проходной_балл,
    CONCAT(ROUND(plan / COUNT(program_enrollee.enrollee_id) * 100), "%") AS Конкурс
FROM program
    JOIN program_enrollee ON program.program_id = program_enrollee.program_id
    JOIN program_subject ON program.program_id = program_subject.program_id
GROUP BY name_program, plan
ORDER BY Конкурс;

=======================================================
/*3.4 База данных «Абитуриент», запросы корректировки*/
=======================================================

/*Создать вспомогательную таблицу applicant,  куда включить id образовательной программы, id абитуриента, сумму баллов 
абитуриентов (столбец itog) в отсортированном сначала по id образовательной программы, а потом по убыванию суммы баллов
 виде (использовать запрос из предыдущего урока)*/
CREATE TABLE applicant AS
SELECT program_id, enrollee.enrollee_id, SUM(result) AS itog
FROM enrollee
     JOIN program_enrollee USING(enrollee_id)
     JOIN program USING(program_id)
     JOIN program_subject USING(program_id)
     JOIN subject USING(subject_id)
     JOIN enrollee_subject USING(enrollee_id, subject_id)
WHERE enrollee_subject.enrollee_id = enrollee.enrollee_id
GROUP BY program_id, enrollee_id
ORDER BY program_id, itog DESC;

SELECT * FROM applicant;
+------------+-------------+------+
| program_id | enrollee_id | itog |
+------------+-------------+------+
| 1          | 3           | 230  |
| 1          | 2           | 226  |
| 1          | 1           | 213  |
| 2          | 6           | 276  |
| 2          | 3           | 230  |
| 2          | 2           | 226  |
| 3          | 6           | 270  |
| 3          | 4           | 238  |
| 3          | 5           | 192  |
| 3          | 1           | 179  |
| 4          | 6           | 270  |
| 4          | 3           | 242  |
| 4          | 5           | 192  |
| 4          | 1           | 179  |
+------------+-------------+------+

/*Из таблицы applicant, созданной на предыдущем шаге, удалить записи, если абитуриент на выбранную образовательную 
программу не набрал минимального балла хотя бы по одному предмету (использовать запрос из предыдущего урока).*/
DELETE FROM applicant
WHERE (program_id, enrollee_id) IN(
    SELECT DISTINCT program.program_id, enrollee.enrollee_id
    FROM enrollee
        INNER JOIN program_enrollee ON program_enrollee.enrollee_id = enrollee.enrollee_id
        INNER JOIN program ON program.program_id = program_enrollee.program_id
        INNER JOIN program_subject ON program_subject.program_id = program.program_id
        INNER JOIN subject ON subject.subject_id = program_subject.subject_id
        INNER JOIN enrollee_subject ON enrollee_subject.subject_id = subject.subject_id
        and enrollee_subject.enrollee_id = enrollee.enrollee_id
    WHERE result < min_result
    );

SELECT * FROM applicant;
+------------+-------------+------+
| program_id | enrollee_id | itog |
+------------+-------------+------+
| 1          | 3           | 230  |
| 1          | 2           | 226  |
| 1          | 1           | 213  |
| 2          | 6           | 276  |
| 2          | 3           | 230  |
| 2          | 2           | 226  |
| 3          | 6           | 270  |
| 3          | 4           | 238  |
| 3          | 5           | 192  |
| 4          | 6           | 270  |
| 4          | 3           | 242  |
| 4          | 5           | 192  |
+------------+-------------+------+

/*Повысить итоговые баллы абитуриентов в таблице applicant на значения дополнительных баллов (использовать запрос из предыдущего урока).*/
UPDATE applicant
    INNER JOIN (    
    SELECT enrollee.enrollee_id, IF(SUM(bonus) IS Null, 0, SUM(bonus)) AS Бонус
    FROM enrollee
        LEFT JOIN enrollee_achievement ON enrollee_achievement.enrollee_id = enrollee.enrollee_id
        LEFT JOIN achievement ON achievement.achievement_id = enrollee_achievement.achievement_id
    GROUP BY enrollee_id
                ) zapros ON applicant.enrollee_id = zapros.enrollee_id
SET itog = itog + zapros.Бонус;

SELECT * FROM applicant;
+------------+-------------+------+
| program_id | enrollee_id | itog |
+------------+-------------+------+
| 1          | 3           | 235  |
| 1          | 2           | 226  |
| 1          | 1           | 219  |
| 2          | 6           | 276  |
| 2          | 3           | 235  |
| 2          | 2           | 226  |
| 3          | 6           | 270  |
| 3          | 4           | 239  |
| 3          | 5           | 200  |
| 4          | 6           | 270  |
| 4          | 3           | 247  |
| 4          | 5           | 200  |
+------------+-------------+------+

/*Поскольку при добавлении дополнительных баллов, абитуриенты по каждой образовательной программе могут следовать не в 
порядке убывания суммарных баллов, необходимо создать новую таблицу applicant_order на основе таблицы applicant. При
 создании таблицы данные нужно отсортировать сначала по id образовательной программы, потом по убыванию итогового балла.
  А таблицу applicant, которая была создана как вспомогательная, необходимо удалить.*/
CREATE TABLE applicant_order AS
    (
    SELECT program_id, enrollee_id, itog
    FROM applicant
    ORDER BY program_id, itog DESC
     );
        
DROP TABLE applicant;
+------------+-------------+------+
| program_id | enrollee_id | itog |
+------------+-------------+------+
| 1          | 3           | 235  |
| 1          | 2           | 226  |
| 1          | 1           | 219  |
| 2          | 6           | 276  |
| 2          | 3           | 235  |
| 2          | 2           | 226  |
| 3          | 6           | 270  |
| 3          | 4           | 239  |
| 3          | 5           | 200  |
| 4          | 6           | 270  |
| 4          | 3           | 247  |
| 4          | 5           | 200  |
+------------+-------------+------+

/*Включить в таблицу applicant_order новый столбец str_id целого типа , расположить его перед первым.*/
ALTER TABLE applicant_order ADD str_id INT FIRST;

SELECT * FROM applicant_order;
+--------+------------+-------------+------+
| str_id | program_id | enrollee_id | itog |
+--------+------------+-------------+------+
| NULL   | 1          | 3           | 235  |
| NULL   | 1          | 2           | 226  |
| NULL   | 1          | 1           | 219  |
| NULL   | 2          | 6           | 276  |
| NULL   | 2          | 3           | 235  |
| NULL   | 2          | 2           | 226  |
| NULL   | 3          | 6           | 270  |
| NULL   | 3          | 4           | 239  |
| NULL   | 3          | 5           | 200  |
| NULL   | 4          | 6           | 270  |
| NULL   | 4          | 3           | 247  |
| NULL   | 4          | 5           | 200  |
+--------+------------+-------------+------+

/*Занести в столбец str_id таблицы applicant_order нумерацию абитуриентов, которая начинается с 1 для каждой 
образовательной программы.*/
SET @num_pr := 0;
SET @row_num := 1;

UPDATE applicant_order 
SET str_id = IF(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1 AND @num_pr := @num_pr + 1);

SELECT * FROM applicant_order;
+--------+------------+-------------+------+
| str_id | program_id | enrollee_id | itog |
+--------+------------+-------------+------+
| 1      | 1          | 3           | 235  |
| 2      | 1          | 2           | 226  |
| 3      | 1          | 1           | 219  |
| 1      | 2          | 6           | 276  |
| 2      | 2          | 3           | 235  |
| 3      | 2          | 2           | 226  |
| 1      | 3          | 6           | 270  |
| 2      | 3          | 4           | 239  |
| 3      | 3          | 5           | 200  |
| 1      | 4          | 6           | 270  |
| 2      | 4          | 3           | 247  |
| 3      | 4          | 5           | 200  |
+--------+------------+-------------+------+

/*Создать таблицу student,  в которую включить абитуриентов, которые могут быть рекомендованы к зачислению  в 
соответствии с планом набора. Информацию отсортировать сначала в алфавитном порядке по названию программ, а потом 
по убыванию итогового балла.*/
CREATE TABLE student AS
SELECT program.name_program, enrollee.name_enrollee, applicant_order.itog
FROM program
    INNER JOIN applicant_order ON applicant_order.program_id = program.program_id
    INNER JOIN enrollee ON enrollee.enrollee_id = applicant_order.enrollee_id
WHERE applicant_order.str_id <= program.plan 
ORDER BY name_program, itog DESC;

SELECT * FROM student;
+-------------------------------------+-----------------+------+
| name_program                        | name_enrollee   | itog |
+-------------------------------------+-----------------+------+
| Математика и компьютерные науки     | Степанова Дарья | 276  |
| Мехатроника и робототехника         | Степанова Дарья | 270  |
| Мехатроника и робототехника         | Семенов Иван    | 247  |
| Мехатроника и робототехника         | Попов Илья      | 200  |
| Прикладная математика и информатика | Семенов Иван    | 235  |
| Прикладная математика и информатика | Абрамова Катя   | 226  |
| Прикладная механика                 | Степанова Дарья | 270  |
| Прикладная механика                 | Яковлева Галина | 239  |
+-------------------------------------+-----------------+------+

/*Придумайте один или несколько запросов корректировки данных
Внести дополнительный столбец achievement, в таблицу applicant_order. Занести название достижения, которую имеет студент. Если достижений у абитуриента нет, вывести - "Достижений нет"*/
ALTER TABLE applicant_order ADD COLUMN achievement VARCHAR(50);

UPDATE applicant_order
INNER JOIN (
    SELECT enrollee_id, GROUP_CONCAT(DISTINCT name_achievement SEPARATOR ', ') AS name_achievement       FROM enrollee
       LEFT JOIN 
    (
        SELECT enrollee_id, name_achievement 
        FROM enrollee_achievement 
        INNER JOIN achievement USING(achievement_id)
    ) quest USING(enrollee_id)
    GROUP BY enrollee_id
    ) q1 USING(enrollee_id)
SET achievement = COALESCE(name_achievement, 'Достижений нет');

SELECT * FROM applicant_order;
+--------+------------+-------------+------+---------------------------------------+
| str_id | program_id | enrollee_id | itog | achievement                           |
+--------+------------+-------------+------+---------------------------------------+
| 1      | 1          | 3           | 235  | Золотая медаль                        |
| 2      | 1          | 2           | 226  | Достижений нет                        |
| 3      | 1          | 1           | 219  | Золотой значок ГТО, Серебряная медаль |
| 1      | 2          | 6           | 276  | Достижений нет                        |
| 2      | 2          | 3           | 235  | Золотая медаль                        |
| 3      | 2          | 2           | 226  | Достижений нет                        |
| 1      | 3          | 6           | 270  | Достижений нет                        |
| 2      | 3          | 4           | 239  | Серебряный значок ГТО                 |
| 3      | 3          | 5           | 200  | Золотая медаль, Золотой значок ГТО    |
| 1      | 4          | 6           | 270  | Достижений нет                        |
| 2      | 4          | 3           | 247  | Золотая медаль                        |
| 3      | 4          | 5           | 200  | Золотая медаль, Золотой значок ГТО    |
+--------+------------+-------------+------+---------------------------------------+

================================================
/*3.5 База данных "Учебная аналитика по курсу"*/
================================================


/*Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные запросы). 
Указать к какому уроку и модулю они относятся. Для этого вывести 3 поля:
-в поле Модуль указать номер модуля и его название через пробел;
-в поле Урок указать номер модуля, порядковый номер урока (lesson_position) через точку и название урока через пробел;
-в поле Шаг указать номер модуля, порядковый номер урока (lesson_position) через точку, порядковый номер шага (step_position) 
через точку и название шага через пробел.
Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце (16 символов
 - это номер модуля или урока, пробел и  название Урока или Модуля к ним присоединить "..."). Информацию отсортировать по возрастанию 
 номеров модулей, порядковых номеров уроков и порядковых номеров шагов.*/
SELECT
    CONCAT(module.module_id, ' ', LEFT(module_name, 14), '...') AS Модуль,
    CONCAT(module.module_id, '.', lesson_position, ' ', LEFT(lesson_name, 12), '...') AS Урок,
    CONCAT(module.module_id, '.', lesson_position, '.', step_position, ' ', step_name) AS Шаг
FROM step
    INNER JOIN lesson ON lesson.lesson_id = step.lesson_id
    INNER JOIN module ON module.module_id = lesson.module_id
WHERE step_name LIKE '%Вложен%запрос%'
ORDER BY Модуль, Урок, Шаг;

===
SET @limit = 19;
WITH steps AS
(
    SELECT
        module_id, lesson_id, lesson_position, step_id, step_position,
        CONCAT(module_id, ' ' , module_name) AS Модуль,
        CONCAT(module_id, '.', lesson_position, ' ' , lesson_name) AS Урок,
        CONCAT(module_id, '.', lesson_position, '.', step_position, ' ' , step_name) AS Шаг
    FROM
        module
        INNER JOIN lesson USING (module_id)
        INNER JOIN step   USING (lesson_id)
    WHERE LOWER(step_name) LIKE '%вложенн% запрос%'
)
SELECT
    IF(LENGTH(Модуль) <= @limit, Модуль, CONCAT(LEFT(Модуль, @limit-3), '...')) AS Модуль,
    IF(LENGTH(Урок)   <= @limit,   Урок, CONCAT(LEFT(  Урок, @limit-3), '...')) AS Урок,
    Шаг
FROM  steps
ORDER BY module_id, lesson_position, step_position;
+---------------------+---------------------+-------------------------------------------------------------+
| Модуль              | Урок                | Шаг                                                         |
+---------------------+---------------------+-------------------------------------------------------------+
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.2 Вложенный запрос, возвращающий одно значение          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.3 Использование вложенного запроса в выражении          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.4 Вложенный запрос, оператор IN                         |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.5 Вложенный запрос, операторы ANY и ALL                 |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.6 Вложенный запрос после SELECT                         |
| 1 Основы реляцио... | 1.5 Запросы корр... | 1.5.5 Добавление записей, вложенные запросы                 |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.7 Запросы для нескольких таблиц со вложенными запросами |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.8 Вложенные запросы в операторах соединения             |
| 2 Запросы SQL к ... | 2.3 Запросы корр... | 2.3.5 Запрос на обновление, вложенные запросы               |
+---------------------+---------------------+-------------------------------------------------------------+

/*Заполнить таблицу step_keyword следующим образом: если ключевое слово есть в названии шага, то включить в step_keyword 
строку с id шага и id ключевого слова. */
INSERT INTO step_keyword (step_id, keyword_id)
    SELECT step_id, keyword_id
    FROM keyword CROSS JOIN step
    WHERE regexp_instr(step_name, concat('\\b', keyword_name, '\\b'));

SELECT * FROM step_keyword;

===
INSERT INTO step_keyword(step_id, keyword_id)
SELECT step_id, keyword_id
FROM step INNER JOIN keyword
     ON INSTR(CONCAT(step_name, ' '), 
              CONCAT(' ', keyword_name, ' ')) OR
        INSTR(CONCAT(step_name, ' '), 
              CONCAT(' ', keyword_name, ',')) OR
        INSTR(CONCAT(step_name, ' '), 
              CONCAT(' ', keyword_name, '('));
+---------+------------+
| step_id | keyword_id |
+---------+------------+
| 38      | 1          |
| 81      | 3          |
| 82      | 4          |
| 82      | 5          |
| 82      | 6          |
| 81      | 7          |
| 82      | 7          |
| 83      | 7          |
| 83      | 8          |
| 47      | 10         |
| 47      | 11         |
| 42      | 15         |
| 43      | 16         |
| 44      | 16         |
| 42      | 17         |
| 43      | 18         |
| 46      | 18         |
| 43      | 19         |
| 88      | 26         |
| 112     | 27         |
| 113     | 27         |
| 37      | 28         |
| 37      | 29         |
| 18      | 30         |
| 36      | 30         |
| 19      | 31         |
| 18      | 32         |
+---------+------------+

/*Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова MAX и AVG одновременно. Для шагов 
указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед заголовком - пробел.
 Позицию шага в уроке вывести в виде двух цифр (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать 
 Шаг. Информацию отсортировать по первому столбцу в алфавитном порядке.*/
SELECT CONCAT(module.module_id, '.', lesson_position, '.', LPAD(step_position, 2, '0'), ' ', step_name) AS Шаг
FROM module
    INNER JOIN lesson USING(module_id)
    INNER JOIN step USING(lesson_id)
    INNER JOIN step_keyword USING(step_id)
    INNER JOIN keyword USING(keyword_id)
WHERE keyword_name='MAX' OR 'AVG'
ORDER BY 1;

===
SELECT 
    concat(module_id,'.',lesson_position,
           IF(step_position < 10, ".0","."),
           step_position," ",step_name) AS Шаг
FROM
   step
   JOIN lesson USING(lesson_id)
   JOIN module USING(module_id)
   JOIN step_keyword USING (step_id)
   JOIN keyword USING(keyword_id)
WHERE keyword_name = 'MAX' OR keyword_name ='AVG'
GROUP BY ШАГ
HAVING COUNT(*) = 2
ORDER BY 1;
+---------------------------------------------------------+
| Шаг                                                     |
+---------------------------------------------------------+
| 1.3.04 Выборка данных, групповые функции MIN, MAX и AVG |
| 1.4.06 Вложенный запрос после SELECT                    |
+---------------------------------------------------------+

/*Посчитать, сколько студентов относится к каждой группе. Столбцы назвать Группа, Интервал, Количество. Указать границы интервала.*/
CREATE TABLE rate
SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
    ) query_in_1;

SELECT Группа, 
 CASE
        WHEN rate <= 10 THEN "от 0 до 10"
        WHEN rate <= 15 THEN "от 11 до 15"
        WHEN rate <= 27 THEN "от 16 до 27"
        ELSE "больше 27"
    END AS Интервал, COUNT(student_name) AS Количество
FROM rate
GROUP BY Группа, Интервал
ORDER BY Группа;

===
CREATE TABLE completed_steps AS
SELECT student_name, 
       COUNT(step_id) AS Пройдено_Шагов,
       CASE WHEN COUNT(step_id) <= 10 THEN "I"
            WHEN COUNT(step_id) <= 15 THEN "II"
            WHEN COUNT(step_id) <= 27 THEN "III"
            ELSE "IV" 
       END AS Группа
FROM student INNER JOIN step_student USING(student_id)
WHERE result = "correct"
GROUP BY student_name
ORDER BY 3, 2, 1;

SELECT Группа,
       CASE WHEN Группа = 'I' THEN "от 0 до 10"
            WHEN Группа = 'II' THEN "от 11 до 15"
            WHEN Группа = 'III' THEN "от 16 до 27"
            ELSE "больше 27" 
       END AS Интервал,
       COUNT(student_name) AS Количество 
FROM completed_steps
GROUP BY Группа;
+--------+-------------+------------+
| Группа | Интервал    | Количество |
+--------+-------------+------------+
| I      | от 0 до 10  | 10         |
| II     | от 11 до 15 | 27         |
| III    | от 16 до 27 | 9          |
| IV     | больше 27   | 18         |
+--------+-------------+------------+

/*Исправить запрос примера так: для шагов, которые  не имеют неверных ответов,  указать 100 как процент успешных попыток,
 если же шаг не имеет верных ответов, указать 0. Информацию отсортировать сначала по возрастанию успешности, а затем по 
 названию шага в алфавитном порядке.*/
WITH table1 (step_name, correct, count) AS (   
SELECT 
  step_name, 
  SUM( IF (result = 'correct' , 1 , 0)) AS s, 
  COUNT(result) AS c
  FROM step 
  JOIN step_student USING (step_id)
  GROUP BY step_name
    )

SELECT  step_name AS Шаг, ROUND((correct/count)*100) AS Успешность
FROM table1
ORDER BY 2, 1

===
WITH tt1 AS (
    SELECT 
       step_name,
       SUM(CASE result WHEN 'correct' THEN 1 ELSE 0 END) c_c,
       SUM(CASE result WHEN 'wrong' THEN 1 ELSE 0 END) c_w
    FROM step INNER JOIN step_student USING (step_id)
    GROUP BY step_name
)
SELECT step_name Шаг,
       IF(c_c = 0, 0, IF(c_w = 0, 100, ROUND((c_c / (c_c + c_w) * 100),0))) Успешность
FROM tt1
ORDER BY 2 ASC,1 ASC;
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------+
| Задание. Работа с архивной таблицей, оператор UNION, часть 1             | 0          |
| Выборка данных, оператор LIKE                                            | 19         |
| Вложенные запросы в операторах соединения                                | 32         |
| Задание. Вывести самый популярный жанр                                   | 33         |
| Запросы для нескольких таблиц с группировкой                             | 33         |
| Задание. Вывести заказы, доставленные с опозданием                       | 35         |
| Задание. Вывести информацию о движении каждого заказа                    | 36         |
| Запросы для нескольких таблиц со вложенными запросами                    | 36         |
| Задание. Вывести подробную информацию о каждом заказе                    | 37         |
| Выборка данных, вычисляемые столбцы, логические функции                  | 44         |
| Операция соединение, использование USING()                               | 45         |
| Перекрестное соединение CROSS JOIN                                       | 45         |
| Задание. Вывести города, в которых живут клиенты магазина                | 48         |
| Задание. Посчитать, сколько раз была заказана каждая книга               | 48         |
| Запросы на основе трех и более связанных таблиц                          | 49         |
| Выборка данных с сортировкой                                             | 53         |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                               | 55         |
| Запросы на выборку из нескольких таблиц                                  | 58         |
| Выборка данных, вычисляемые столбцы, математические функции              | 59         |
| Задание. Вывести клиентов, которые заказывали книги определенного автора | 63         |
| Задание. Вывести информацию об оплате каждого заказа                     | 65         |
| Выборка данных, логические операции                                      | 67         |
| Проектирование концептуальной модели базы данных                         | 70         |
| Выборка данных, операторы BETWEEN, IN                                    | 72         |
| Выборка данных с созданием вычисляемого столбца                          | 74         |
| Выборка отдельных столбцов                                               | 76         |
| Соединение INNER JOIN                                                    | 78         |
| Выборка данных по условию                                                | 81         |
| Выборка отдельных столбцов и присвоение им новых имен                    | 84         |
| Выборка всех данных из таблицы                                           | 87         |
| Задание. Работа с архивной таблицей, оператор UNION, часть 2             | 100        |
| Построение логической схемы базы данных                                  | 100        |
+--------------------------------------------------------------------------+------------+

/*Вычислить прогресс пользователей по курсу. Прогресс вычисляется как отношение верно пройденных шагов к общему количеству 
шагов в процентах, округленное до целого. В нашей базе данные о решениях занесены не для всех шагов, поэтому общее количество
 шагов определить как количество различных шагов в таблице step_student.

Тем пользователям, которые прошли все шаги (прогресс = 100%) выдать "Сертификат с отличием". Тем, у кого прогресс больше или 
равен 80% - "Сертификат". Для остальных записей в столбце Результат задать пустую строку ("").

Информацию отсортировать по убыванию прогресса, затем по имени пользователя в алфавитном порядке.*/
SET @max = (SELECT COUNT(DISTINCT step_id) FROM step_student);

WITH table_result(student_name, result_student)
   AS (
    SELECT student_name, ROUND(COUNT(DISTINCT step_id) / @max * 100)
    FROM student JOIN step_student USING(student_id)
    WHERE result = "correct"
    GROUP BY student_name
    ORDER BY 2 DESC
    )
SELECT student_name AS Студент, result_student AS Прогресс,
    CASE
        WHEN result_student = 100 THEN 'Сертификат с отличием'
        WHEN result_student >= 80 THEN 'Сертификат'
        ELSE ''
    END AS Результат
FROM table_result
ORDER BY Прогресс DESC, Студент;

===

WITH all_step (step_vse)
AS (SELECT COUNT(DISTINCT step_id) FROM step_student),
cor_step (step_vern, name_stud)
AS (SELECT COUNT(DISTINCT step_id), student_name
FROM (SELECT step_id, student_name
    FROM student JOIN step_student USING (student_id)
    where result = "correct")query_in 
    GROUP BY student_name)
SELECT name_stud AS Студент, ROUND(step_vern / step_vse * 100) AS Прогресс,
CASE
        WHEN ROUND(step_vern / step_vse * 100) = 100 THEN "Сертификат с отличием"
        WHEN ROUND(step_vern / step_vse * 100) >= 80 THEN "Сертификат"
        ELSE ""
    END AS Результат
FROM all_step CROSS JOIN cor_step
ORDER BY 2 DESC, 1;
+------------+----------+-----------------------+
| Студент    | Прогресс | Результат             |
+------------+----------+-----------------------+
| student_60 | 100      | Сертификат с отличием |
| student_15 | 94       | Сертификат            |
| student_18 | 94       | Сертификат            |
| student_27 | 94       | Сертификат            |
| student_30 | 94       | Сертификат            |
| student_31 | 94       | Сертификат            |
| student_36 | 94       | Сертификат            |
| student_39 | 94       | Сертификат            |
| student_4  | 94       | Сертификат            |
| student_43 | 94       | Сертификат            |
| student_44 | 94       | Сертификат            |
| student_46 | 94       | Сертификат            |
| student_49 | 94       | Сертификат            |
| student_51 | 94       | Сертификат            |
| student_53 | 94       | Сертификат            |
| student_59 | 91       | Сертификат            |
| student_9  | 91       | Сертификат            |
| student_23 | 88       | Сертификат            |
| student_50 | 84       | Сертификат            |
| student_20 | 78       |                       |
| student_24 | 78       |                       |
| student_52 | 63       |                       |
| student_56 | 63       |                       |
| student_34 | 59       |                       |
| student_40 | 59       |                       |
| student_11 | 50       |                       |
| student_48 | 50       |                       |
| student_42 | 47       |                       |
| student_61 | 44       |                       |
| student_13 | 41       |                       |
| student_26 | 41       |                       |
| student_1  | 34       |                       |
| student_10 | 34       |                       |
| student_12 | 34       |                       |
| student_14 | 34       |                       |
| student_19 | 34       |                       |
| student_2  | 34       |                       |
| student_21 | 34       |                       |
| student_22 | 34       |                       |
| student_25 | 34       |                       |
| student_28 | 34       |                       |
| student_3  | 34       |                       |
| student_32 | 34       |                       |
| student_35 | 34       |                       |
| student_37 | 34       |                       |
| student_41 | 34       |                       |
| student_45 | 34       |                       |
| student_54 | 34       |                       |
| student_55 | 34       |                       |
| student_57 | 34       |                       |
| student_6  | 34       |                       |
| student_62 | 34       |                       |
| student_7  | 34       |                       |
| student_8  | 34       |                       |
| student_17 | 31       |                       |
| student_33 | 31       |                       |
| student_38 | 31       |                       |
| student_58 | 31       |                       |
| student_64 | 31       |                       |
| student_16 | 28       |                       |
| student_5  | 28       |                       |
| student_63 | 28       |                       |
| student_29 | 25       |                       |
| student_47 | 25       |                       |
+------------+----------+-----------------------+

/*Для студента с именем student_61 вывести все его попытки: название шага, результат и дату отправки попытки (submission_time). 
Информацию отсортировать по дате отправки попытки и указать, сколько минут прошло между отправкой соседних попыток. Название шага
 ограничить 20 символами и добавить "...". Столбцы назвать Студент, Шаг, Результат, Дата_отправки, Разница*/
SELECT student_name AS Студент,
CONCAT(LEFT(step_name, 20), '...') AS Шаг,
result AS Результат,
FROM_UNIXTIME(submission_time) AS Дата_отправки,
SEC_TO_TIME(submission_time - LAG(submission_time, 1, submission_time) OVER (ORDER BY submission_time)) AS Разница
FROM step
    INNER JOIN step_student USING (step_id)
    INNER JOIN student USING(student_id)
WHERE student_name = 'student_61'
ORDER BY Дата_отправки

===
SELECT 
    student_name AS 'Студент',
    CONCAT(LEFT(step_name,20),'...') AS 'Шаг',
    result AS 'Результат',
    FROM_UNIXTIME(submission_time) AS 'Дата_отправки',
    SEC_TO_TIME(submission_time - 
                LAG(submission_time,1,submission_time) 
                OVER (ORDER BY submission_time)) AS 'Разница'
/* 
LAG(submission_time,1,submission_time) 
первый аргумент - LAG(submission_time) - предыдущая сабмишн
второй аргумент - 1 - через сколько строк брать предыдущее значение
третий аргумент - submission_time - Если вычисленное значение Null, то взять текущее значение сабмишн
*/   
FROM 
    step_student
    JOIN student USING(student_id)
    JOIN step USING(step_id)
WHERE student_name = 'student_61'
ORDER BY 4
+------------+-------------------------+-----------+---------------------+------------------+
| Студент    | Шаг                     | Результат | Дата_отправки       | Разница          |
+------------+-------------------------+-----------+---------------------+------------------+
| student_61 | Выборка всех данных ... | correct   | 2020-08-27 14:22:14 | 0:00:00          |
| student_61 | Выборка отдельных ст... | correct   | 2020-08-27 14:23:53 | 0:01:39          |
| student_61 | Выборка отдельных ст... | correct   | 2020-08-27 14:28:41 | 0:04:48          |
| student_61 | Выборка данных с соз... | wrong     | 2020-08-27 14:33:57 | 0:05:16          |
| student_61 | Выборка данных с соз... | wrong     | 2020-08-27 14:34:24 | 0:00:27          |
| student_61 | Выборка данных с соз... | correct   | 2020-08-27 14:34:50 | 0:00:26          |
| student_61 | Выборка данных, вычи... | correct   | 2020-08-27 14:42:44 | 0:07:54          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 14:54:06 | 0:11:22          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 14:55:04 | 0:00:58          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 14:58:23 | 0:03:19          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 14:58:56 | 0:00:33          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 14:59:09 | 0:00:13          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 14:59:49 | 0:00:40          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 15:01:00 | 0:01:11          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 15:05:20 | 0:04:20          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 15:06:19 | 0:00:59          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 15:06:58 | 0:00:39          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 15:08:40 | 0:01:42          |
| student_61 | Выборка данных, вычи... | wrong     | 2020-08-27 15:09:02 | 0:00:22          |
| student_61 | Выборка данных, вычи... | correct   | 2020-08-27 15:13:06 | 0:04:04          |
| student_61 | Выборка данных по ус... | wrong     | 2020-08-27 15:21:02 | 0:07:56          |
| student_61 | Выборка данных по ус... | correct   | 2020-08-27 15:21:18 | 0:00:16          |
| student_61 | Выборка данных, логи... | correct   | 2020-08-27 15:26:05 | 0:04:47          |
| student_61 | Выборка данных, опер... | correct   | 2020-08-27 15:31:31 | 0:05:26          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:42:30 | 0:10:59          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:43:35 | 0:01:05          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:48:09 | 0:04:34          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:49:47 | 0:01:38          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:52:13 | 0:02:26          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:57:41 | 0:05:28          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:57:53 | 0:00:12          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:58:28 | 0:00:35          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 15:59:58 | 0:01:30          |
| student_61 | Выборка данных, опер... | wrong     | 2020-08-27 16:00:22 | 0:00:24          |
| student_61 | Выборка данных, опер... | correct   | 2020-08-27 16:01:05 | 0:00:43          |
| student_61 | Выборка данных с сор... | wrong     | 2020-08-27 16:12:51 | 0:11:46          |
| student_61 | Выборка данных с сор... | correct   | 2020-08-27 16:14:15 | 0:01:24          |
| student_61 | Соединение INNER JOI... | correct   | 2020-09-01 07:25:39 | 4 days, 15:11:24 |
| student_61 | Внешнее соединение L... | wrong     | 2020-09-01 09:53:30 | 2:27:51          |
| student_61 | Внешнее соединение L... | correct   | 2020-09-01 09:53:50 | 0:00:20          |
| student_61 | Перекрестное соедине... | wrong     | 2020-09-01 10:45:30 | 0:51:40          |
| student_61 | Перекрестное соедине... | wrong     | 2020-09-01 10:46:21 | 0:00:51          |
| student_61 | Перекрестное соедине... | correct   | 2020-09-01 10:47:55 | 0:01:34          |
+------------+-------------------------+-----------+---------------------+------------------+

/*Посчитать среднее время, за которое пользователи проходят урок по следующему алгоритму:
для каждого пользователя вычислить время прохождения шага как сумму времени, потраченного на каждую попытку (время 
попытки - это разница между временем отправки задания и временем начала попытки), при этом попытки, которые длились 
больше 4 часов не учитывать, так как пользователь мог просто оставить задание открытым в браузере, а вернуться к нему 
на следующий день;
для каждого студента посчитать общее время, которое он затратил на каждый урок;
вычислить среднее время выполнения урока в часах, результат округлить до 2-х знаков после запятой;
вывести информацию по возрастанию времени, пронумеровав строки, для каждого урока указать номер модуля и его позицию в нем.
Столбцы результата назвать Номер, Урок, Среднее_время.*/
SELECT ROW_NUMBER() OVER (ORDER BY Среднее_время) AS Номер,
    Урок,
    Среднее_время
FROM(
    SELECT Урок,
    ROUND(AVG(difference), 2) AS Среднее_время
    FROM(
        SELECT student_id, 
        CONCAT(module_id, '.', lesson_position, ' ', lesson_name) AS Урок,
        SUM((submission_time - attempt_time) / 3600) AS difference
        FROM module
            INNER JOIN lesson USING (module_id)
            INNER JOIN step USING (lesson_id)
            INNER JOIN step_student USING (step_id)
        WHERE submission_time - attempt_time <= 4 * 3600
        GROUP BY 1, 2
     ) AS query_1
GROUP BY 1
) AS query_2
ORDER BY 3;
+-------+-------------------------------------------------------------+---------------+
| Номер | Урок                                                        | Среднее_время |
+-------+-------------------------------------------------------------+---------------+
| 1     | 2.2 Запросы на выборку, соединение таблиц                   | 2.37          |
| 2     | 1.2 Выборка данных                                          | 2.65          |
| 3     | 2.4 База данных "Интернет-магазин книг", запросы на выборку | 3.65          |
+-------+-------------------------------------------------------------+---------------+
