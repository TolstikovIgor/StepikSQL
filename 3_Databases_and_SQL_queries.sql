
============================================
/*3.1 База данных «Тестирование», запросы на выборку*/
============================================

/*Вывести студентов, которые сдавали дисциплину «Основы баз данных», указать дату попытки и результат. 
Информацию вывести по убыванию результатов тестирования.*/
SELECT name_student, date_attempt, result
FROM attempt
    INNER JOIN student USING(student_id)
    INNER JOIN subject USING(subject_id)
WHERE subject_id = 2
ORDER BY result DESC;
+-----------------+--------------+--------+
| name_student    | date_attempt | result |
+-----------------+--------------+--------+
| Яковлева Галина | 2020-04-21   | 100    |
| Баранов Павел   | 2020-03-23   | 67     |
| Яковлева Галина | 2020-03-26   | 0      |
+-----------------+--------------+--------+

/*Вывести, сколько попыток сделали студенты по каждой дисциплине, а также средний результат попыток, который 
округлить до 2 знаков после запятой. Под результатом попытки понимается процент правильных ответов на вопросы 
теста, который занесен в столбец result.  В результат включить название дисциплины, а также вычисляемые столбцы 
Количество и Среднее. Информацию вывести по убыванию средних результатов.*/
SELECT name_subject, COUNT(result) AS Количество, ROUND(AVG(attempt.result),2) AS Среднее
FROM attempt
    RIGHT JOIN subject USING(subject_id)
GROUP BY name_subject
ORDER BY Среднее DESC;
+-------------------+------------+---------+
| name_subject      | Количество | Среднее |
+-------------------+------------+---------+
| Основы SQL        | 4          | 58.25   |
| Основы баз данных | 3          | 55.67   |
| Физика            | 0          | NULL    |
+-------------------+------------+---------+

/*Вывести студентов (различных студентов), имеющих максимальные результаты попыток. Информацию отсортировать в 
алфавитном порядке по фамилии студента.*/
SELECT name_student, attempt.result
FROM attempt
    INNER JOIN student USING(student_id)
WHERE result = (
    SELECT MAX(result)
    FROM attempt)
ORDER BY name_student;
+-----------------+--------+
| name_student    | result |
+-----------------+--------+
| Семенов Иван    | 100    |
| Яковлева Галина | 100    |
+-----------------+--------+

/*Если студент совершал несколько попыток по одной и той же дисциплине, то вывести разницу в днях между первой и 
последней попыткой. В результат включить фамилию и имя студента, название дисциплины и вычисляемый столбец Интервал.
Информацию вывести по возрастанию разницы. Студентов, сделавших одну попытку по дисциплине, не учитывать. */
SELECT name_student, name_subject, DATEDIFF(MAX(date_attempt), MIN(date_attempt)) AS Интервал
FROM attempt
    INNER JOIN student USING(student_id)
    INNER JOIN subject USING(subject_id)
WHERE attempt.student_id > 1 AND attempt.subject_id = subject.subject_id
GROUP BY name_student, name_subject
ORDER BY Интервал;
+-----------------+-------------------+----------+
| name_student    | name_subject      | Интервал |
+-----------------+-------------------+----------+
| Яковлева Галина | Основы баз данных | 26       |
| Семенов Иван    | Основы SQL        | 55       |
+-----------------+-------------------+----------+

/*Студенты могут тестироваться по одной или нескольким дисциплинам (не обязательно по всем). Вывести дисциплину и количество
уникальных студентов (столбец назвать Количество), которые по ней проходили тестирование . Информацию отсортировать сначала
по убыванию количества, а потом по названию дисциплины. В результат включить и дисциплины, тестирование по которым студенты
еще не проходили, в этом случае указать количество студентов 0.*/
SELECT name_subject, COUNT(DISTINCT(attempt.student_id)) AS Количество
FROM attempt
    RIGHT JOIN subject USING(subject_id)
GROUP BY name_subject
ORDER BY Количество DESC, name_subject;
+-------------------+------------+
| name_subject      | Количество |
+-------------------+------------+
| Основы SQL        | 2          |
| Основы баз данных | 2          |
| Физика            | 0          |
+-------------------+------------+

/*Случайным образом отберите 3 вопроса по дисциплине «Основы баз данных». В результат включите столбцы question_id и name_question.*/
SELECT question_id, name_question
FROM question
    INNER JOIN subject USING(subject_id)
WHERE subject.name_subject = 'Основы баз данных'
ORDER BY RAND()
LIMIT 3;
+-------------+----------------------------------------+
| question_id | name_question                          |
+-------------+----------------------------------------+
| 7           | Отношение - это:                       |
| 6           | База данных - это:                     |
| 8           | Концептуальная модель используется для |
+-------------+----------------------------------------+

/*Вывести вопросы, которые были включены в тест для Семенова Ивана по дисциплине «Основы SQL» 2020-05-17  (значение attempt_id
для этой попытки равно 7). Указать, какой ответ дал студент и правильный он или нет (вывести Верно или Неверно). В результат 
включить вопрос, ответ и вычисляемый столбец  Результат.*/
SELECT name_question, answer.name_answer, IF(answer.is_correct = TRUE,'Верно','Неверно') AS Результат
FROM testing
    INNER JOIN question ON testing.question_id = question.question_id
    INNER JOIN answer ON answer.answer_id = testing.answer_id
WHERE testing.attempt_id = 7;
+----------------------------------------------------------+-----------------------+-----------+
| name_question                                            | name_answer           | Результат |
+----------------------------------------------------------+-----------------------+-----------+
| Запрос на выборку начинается с ключевого слова:          | INSERT                | Неверно   |
| Какой запрос выбирает все записи из таблицы student:     | SELECT * FROM student | Верно     |
| Для внутреннего соединения таблиц используется оператор: | CROSS JOIN            | Неверно   |
+----------------------------------------------------------+-----------------------+-----------+

/*Посчитать результаты тестирования. Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество
вопросов в каждой попытке) и умноженное на 100. Результат округлить до двух знаков после запятой. Вывести фамилию студента,
название предмета, дату и результат. Последний столбец назвать Результат. Информацию отсортировать сначала по фамилии студента,
потом по убыванию даты попытки.*/
SELECT name_student, name_subject, date_attempt,  ROUND(SUM(is_correct)*100/3, 2) AS Результат
FROM attempt
    INNER JOIN student ON attempt.student_id = student.student_id
    INNER JOIN subject ON subject.subject_id = attempt.subject_id
    INNER JOIN testing ON testing.attempt_id = attempt.attempt_id
    INNER JOIN answer ON answer.answer_id = testing.answer_id
GROUP BY name_student, name_subject, date_attempt
ORDER BY name_student, date_attempt DESC;
+-----------------+-------------------+--------------+-----------+
| name_student    | name_subject      | date_attempt | Результат |
+-----------------+-------------------+--------------+-----------+
| Баранов Павел   | Основы SQL        | 2020-04-15   | 33.33     |
| Баранов Павел   | Основы баз данных | 2020-03-23   | 66.67     |
| Семенов Иван    | Основы SQL        | 2020-05-17   | 33.33     |
| Семенов Иван    | Основы SQL        | 2020-04-15   | 66.67     |
| Семенов Иван    | Основы SQL        | 2020-03-23   | 100.00    |
| Яковлева Галина | Основы баз данных | 2020-04-21   | 100.00    |
| Яковлева Галина | Основы баз данных | 2020-03-26   | 0.00      |
+-----------------+-------------------+--------------+-----------+

/*Для каждого вопроса вывести процент успешных решений, то есть отношение количества верных ответов к общему количеству 
ответов, значение округлить до 2-х знаков после запятой. Также вывести название предмета, к которому относится вопрос, и
 общее количество ответов на этот вопрос. В результат включить название дисциплины, вопросы по ней (столбец назвать Вопрос),
а также два вычисляемых столбца Всего_ответов и Успешность. Информацию отсортировать сначала по названию дисциплины, потом по
 убыванию успешности, а потом по тексту вопроса в алфавитном порядке.*/
SELECT name_subject, CONCAT(LEFT(name_question, 30), '...') AS Вопрос, COUNT(is_correct) AS Всего_ответов, ROUND(SUM(is_correct) / COUNT(is_correct)*100, 2) AS Успешность 
FROM attempt
    INNER JOIN student ON attempt.student_id = student.student_id
    INNER JOIN subject ON subject.subject_id = attempt.subject_id
    INNER JOIN testing ON testing.attempt_id = attempt.attempt_id
    INNER JOIN answer ON answer.answer_id = testing.answer_id
    INNER JOIN question ON question.question_id = answer.question_id
GROUP BY name_subject, Вопрос
ORDER BY name_subject, Успешность DESC, Вопрос;
+-------------------+-----------------------------------+---------------+------------+
| name_subject      | Вопрос                            | Всего_ответов | Успешность |
+-------------------+-----------------------------------+---------------+------------+
| Основы SQL        | Условие, по которому отбираютс... | 1             | 100.00     |
| Основы SQL        | Запрос на выборку начинается с... | 4             | 75.00      |
| Основы SQL        | Какой запрос выбирает все запи... | 3             | 66.67      |
| Основы SQL        | Для сортировки используется:...   | 2             | 50.00      |
| Основы SQL        | Для внутреннего соединения таб... | 2             | 0.00       |
| Основы баз данных | База данных - это:...             | 3             | 66.67      |
| Основы баз данных | Какой тип данных не допустим в... | 2             | 50.00      |
| Основы баз данных | Концептуальная модель использу... | 2             | 50.00      |
| Основы баз данных | Отношение - это:...               | 2             | 50.00      |
+-------------------+-----------------------------------+---------------+------------+

/*Придумайте один или несколько запросов на выборку
Вывести количество ответов и среднюю успешность (процент правильных ответов) по каждому студенту. Отсортировать по средней успешности по убыванию.*/
SELECT name_student, IF (COUNT(attempt.attempt_id) > 0, round(SUM(answer.is_correct) / COUNT(testing.testing_id) * 100, 2), 0) AS Правильных_ответов
FROM student
      LEFT JOIN attempt ON attempt.student_id = student.student_id
      LEFT JOIN testing ON testing.attempt_id = attempt.attempt_id
      LEFT JOIN answer ON answer.answer_id = testing.answer_id
GROUP BY student.student_id
ORDER BY Правильных_ответов DESC;
+-----------------+--------------------+
| name_student    | Правильных_ответов |
+-----------------+--------------------+
| Семенов Иван    | 66.67              |
| Баранов Павел   | 50.00              |
| Яковлева Галина | 50.00              |
| Абрамова Катя   | 0                  |
+-----------------+--------------------+

=========================================================
/*3.2 База данных «Тестирование», запросы корректировки*/
=========================================================

/*В таблицу attempt включить новую попытку для студента Баранова Павла по дисциплине «Основы баз данных». Установить
 текущую дату в качестве даты выполнения попытки.*/
INSERT INTO attempt (student_id, subject_id, date_attempt, result)
SELECT 
    (SELECT student_id FROM student WHERE name_student = 'Баранов Павел'),
    (SELECT subject_id FROM subject WHERE name_subject = 'Основы баз данных'),
    NOW(),
    Null;

SELECT * FROM attempt;
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2022-06-25   | NULL   |
+------------+------------+------------+--------------+--------+

/*Случайным образом выбрать три вопроса (запрос) по дисциплине, тестирование по которой собирается проходить студент, 
занесенный в таблицу attempt последним, и добавить их в таблицу testing. id последней попытки получить как максимальное
 значение id из таблицы attempt.*/
INSERT INTO testing (attempt_id, question_id)
SELECT attempt_id, question_id
FROM attempt
    INNER JOIN question ON attempt.subject_id = question.subject_id
WHERE attempt_id = (SELECT MAX(attempt_id) FROM attempt) 
ORDER BY RAND()
LIMIT 3;

Select * FROM testing;

/*Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат
(запрос) и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных
 ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.
Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 8.*/
UPDATE attempt 
SET result = (SELECT ROUND(SUM(is_correct)*100/3) AS Результат
FROM testing 
    INNER JOIN answer ON answer.answer_id = testing.answer_id
    WHERE attempt_id = 8)
WHERE attempt_id = 8;
              
SELECT * FROM attempt;
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2020-06-12   | 67     |
+------------+------------+------------+--------------+--------+

/*Удалить из таблицы attempt все попытки, выполненные раньше 1 мая 2020 года. Также удалить и все соответствующие этим 
попыткам вопросы из таблицы testing, которая создавалась следующим запросом:*/
DELETE FROM attempt, testing
USING 
    attempt 
    INNER JOIN testing ON testing.attempt_id = attempt.attempt_id
WHERE attempt.date_attempt < '2020-05-01';

SELECT * FROM attempt;
SELECT * FROM testing;
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2020-06-12   | 67     |
+------------+------------+------------+--------------+--------+
Affected rows: 2

Query result:
+------------+------------+-------------+-----------+
| testing_id | attempt_id | question_id | answer_id |
+------------+------------+-------------+-----------+
| 19         | 7          | 1           | 3         |
| 20         | 7          | 4           | 11        |
| 21         | 7          | 5           | 16        |
| 22         | 8          | 7           | 19        |
| 23         | 8          | 6           | 17        |
| 24         | 8          | 8           | 22        |
+------------+------------+-------------+-----------+

/*Придумайте один или несколько запросов корректировки данных
Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат
(запрос) и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных
 ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.
Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 5.*/
UPDATE attempt 
SET result = (SELECT ROUND(SUM(is_correct)*100/3)
FROM answer
    INNER JOIN testing ON answer.answer_id = testing.answer_id
    WHERE attempt_id = 5)
WHERE attempt_id = 5;

SELECT * FROM attempt;
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
+------------+------------+------------+--------------+--------+

=====================================================
/*3.3 База данных «Абитуриент», запросы на выборку*/
=====================================================

/*Вывести абитуриентов, которые хотят поступать на образовательную программу «Мехатроника и робототехника» в 
отсортированном по фамилиям виде.*/
SELECT name_enrollee
FROM program
    INNER JOIN program_enrollee ON program_enrollee.program_id = program.program_id
    INNER JOIN enrollee ON enrollee.enrollee_id = program_enrollee.enrollee_id
WHERE program.name_program = 'Мехатроника и робототехника'
ORDER BY name_enrollee;
+-----------------+
| name_enrollee   |
+-----------------+
| Баранов Павел   |
| Попов Илья      |
| Семенов Иван    |
| Степанова Дарья |
+-----------------+

/*Вывести образовательные программы, на которые для поступления необходим предмет «Информатика». Программы отсортировать
 в обратном алфавитном порядке.*/
SELECT name_program
FROM program
    INNER JOIN program_subject ON program_subject.program_id = program.program_id
    INNER JOIN subject ON subject.subject_id = program_subject.subject_id
WHERE subject.name_subject = 'Информатика'
ORDER BY name_program DESC;
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Прикладная математика и информатика |
| Математика и компьютерные науки     |
+-------------------------------------+

/*Выведите количество абитуриентов, сдавших ЕГЭ по каждому предмету, максимальное, минимальное и среднее значение баллов
по предмету ЕГЭ. Вычисляемые столбцы назвать Количество, Максимум, Минимум, Среднее. Информацию отсортировать по названию
предмета в алфавитном порядке, среднее значение округлить до одного знака после запятой.*/
SELECT name_subject, 
    COUNT(result) AS Количество, 
    MAX(result) AS Максимум,
    MIN(result) AS Минимум,
    ROUND(AVG(result), 1) AS Среднее
FROM enrollee_subject
    INNER JOIN subject ON subject.subject_id = enrollee_subject.subject_id
GROUP BY name_subject
ORDER BY name_subject;
+--------------+------------+----------+---------+---------+
| name_subject | Количество | Максимум | Минимум | Среднее |
+--------------+------------+----------+---------+---------+
| Информатика  | 4          | 94       | 75      | 82.0    |
| Математика   | 6          | 92       | 67      | 75.3    |
| Русский язык | 6          | 90       | 65      | 77.5    |
| Физика       | 5          | 90       | 41      | 69.8    |
+--------------+------------+----------+---------+---------+

/*Вывести образовательные программы, для которых минимальный балл ЕГЭ по каждому предмету больше или равен 40 баллам.
Программы вывести в отсортированном по алфавиту виде.*/
SELECT name_program
FROM program
    INNER JOIN program_subject ON program_subject.program_id = program.program_id
GROUP BY name_program
HAVING MIN(min_result) >= 40
ORDER BY name_program;
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Мехатроника и робототехника         |
| Прикладная математика и информатика |
+-------------------------------------+

/*Вывести образовательные программы, которые имеют самый большой план набора,  вместе с этой величиной.*/
SELECT name_program, plan
FROM program
WHERE plan = (SELECT MAX(plan) FROM program);
+-----------------------------+------+
| name_program                | plan |
+-----------------------------+------+
| Мехатроника и робототехника | 3    |
+-----------------------------+------+

/*Посчитать, сколько дополнительных баллов получит каждый абитуриент. Столбец с дополнительными баллами назвать Бонус.
Информацию вывести в отсортированном по фамилиям виде.*/
SELECT name_enrollee, IF(SUM(bonus) IS Null, 0, SUM(bonus)) AS Бонус
FROM enrollee
    LEFT JOIN enrollee_achievement ON enrollee_achievement.enrollee_id = enrollee.enrollee_id
    LEFT JOIN achievement ON achievement.achievement_id = enrollee_achievement.achievement_id
GROUP BY name_enrollee
ORDER BY name_enrollee;
+-----------------+-------+
| name_enrollee   | Бонус |
+-----------------+-------+
| Абрамова Катя   | 0     |
| Баранов Павел   | 6     |
| Попов Илья      | 8     |
| Семенов Иван    | 5     |
| Степанова Дарья | 0     |
| Яковлева Галина | 1     |
+-----------------+-------+

/*Выведите сколько человек подало заявление на каждую образовательную программу и конкурс на нее (число поданных заявлений деленное на количество мест по плану), округленный до 2-х знаков после запятой. В запросе вывести название факультета, к которому относится образовательная программа, название образовательной программы, план набора абитуриентов на образовательную программу (plan), количество поданных заявлений (Количество) и Конкурс. Информацию отсортировать в порядке убывания конкурса.*/
SELECT name_department, name_program, plan, COUNT(enrollee_id) AS Количество, ROUND(COUNT(enrollee_id) / plan, 2) AS Конкурс
FROM program
    INNER JOIN program_enrollee ON program_enrollee.program_id = program.program_id
    INNER JOIN department ON program.department_id = department.department_id
GROUP BY name_department, name_program, plan
ORDER BY Конкурс DESC;
+-------------------------+-------------------------------------+------+------------+---------+
| name_department         | name_program                        | plan | Количество | Конкурс |
+-------------------------+-------------------------------------+------+------------+---------+
| Школа естественных наук | Математика и компьютерные науки     | 1    | 3          | 3.00    |
| Инженерная школа        | Прикладная механика                 | 2    | 4          | 2.00    |
| Школа естественных наук | Прикладная математика и информатика | 2    | 3          | 1.50    |
| Инженерная школа        | Мехатроника и робототехника         | 3    | 4          | 1.33    |
+-------------------------+-------------------------------------+------+------------+---------+

/*Вывести образовательные программы, на которые для поступления необходимы предмет «Информатика» и «Математика» в 
отсортированном по названию программ виде.*/
SELECT name_program
FROM program
WHERE name_program LIKE '%Математика%' OR name_program LIKE '%Информатика%'
GROUP BY name_program
ORDER BY name_program;
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Математика и компьютерные науки     |
| Прикладная математика и информатика |
+-------------------------------------+

/*Посчитать количество баллов каждого абитуриента на каждую образовательную программу, на которую он подал заявление, 
по результатам ЕГЭ. В результат включить название образовательной программы, фамилию и имя абитуриента, а также столбец 
с суммой баллов, который назвать itog. Информацию вывести в отсортированном сначала по образовательной программе, а потом 
по убыванию суммы баллов виде.*/
SELECT name_program, name_enrollee, SUM(result) AS itog
FROM enrollee
    INNER JOIN program_enrollee ON program_enrollee.enrollee_id = enrollee.enrollee_id
    INNER JOIN program ON program.program_id = program_enrollee.program_id
    INNER JOIN program_subject ON program_subject.program_id = program.program_id
    INNER JOIN subject ON subject.subject_id = program_subject.subject_id
    INNER JOIN enrollee_subject ON enrollee_subject.subject_id = subject.subject_id
    and enrollee_subject.enrollee_id = enrollee.enrollee_id
GROUP BY name_program, name_enrollee
ORDER BY name_program, itog DESC;
+-------------------------------------+-----------------+------+
| name_program                        | name_enrollee   | itog |
+-------------------------------------+-----------------+------+
| Математика и компьютерные науки     | Степанова Дарья | 276  |
| Математика и компьютерные науки     | Семенов Иван    | 230  |
| Математика и компьютерные науки     | Абрамова Катя   | 226  |
| Мехатроника и робототехника         | Степанова Дарья | 270  |
| Мехатроника и робототехника         | Семенов Иван    | 242  |
| Мехатроника и робототехника         | Попов Илья      | 192  |
| Мехатроника и робототехника         | Баранов Павел   | 179  |
| Прикладная математика и информатика | Семенов Иван    | 230  |
| Прикладная математика и информатика | Абрамова Катя   | 226  |
| Прикладная математика и информатика | Баранов Павел   | 213  |
| Прикладная механика                 | Степанова Дарья | 270  |
| Прикладная механика                 | Яковлева Галина | 238  |
| Прикладная механика                 | Попов Илья      | 192  |
| Прикладная механика                 | Баранов Павел   | 179  |
+-------------------------------------+-----------------+------+

/*Вывести название образовательной программы и фамилию тех абитуриентов, которые подавали документы на эту образовательную
 программу, но не могут быть зачислены на нее. Эти абитуриенты имеют результат по одному или нескольким предметам ЕГЭ, 
 необходимым для поступления на эту образовательную программу, меньше минимального балла. Информацию вывести в отсортированном
  сначала по программам, а потом по фамилиям абитуриентов виде.*/
SELECT name_program, name_enrollee
FROM enrollee
    INNER JOIN program_enrollee ON program_enrollee.enrollee_id = enrollee.enrollee_id
    INNER JOIN program ON program.program_id = program_enrollee.program_id
    INNER JOIN program_subject ON program_subject.program_id = program.program_id
    INNER JOIN subject ON subject.subject_id = program_subject.subject_id
    INNER JOIN enrollee_subject ON enrollee_subject.subject_id = subject.subject_id
    and enrollee_subject.enrollee_id = enrollee.enrollee_id
WHERE result < min_result
ORDER BY name_program, name_enrollee;
+-----------------------------+---------------+
| name_program                | name_enrollee |
+-----------------------------+---------------+
| Мехатроника и робототехника | Баранов Павел |
| Прикладная механика         | Баранов Павел |
+-----------------------------+---------------+

/*Придумайте один или несколько запросов на выборку для предметной области «Абитуриент»
Выбрать программы с минимальным конкурсом. Для этого составить список программ с указанием проходного балла и конкурса. Отсортировать по конкурсу.*/
SELECT name_program,
    SUM(min_result) AS Проходной_балл,
    CONCAT(ROUND(plan / COUNT(program_enrollee.enrollee_id) * 100), "%") AS Конкурс
FROM program
    JOIN program_enrollee ON program.program_id = program_enrollee.program_id
    JOIN program_subject ON program.program_id = program_subject.program_id
GROUP BY name_program, plan
ORDER BY Конкурс;

=======================================================
/*3.4 База данных «Абитуриент», запросы корректировки*/
=======================================================

/*Создать вспомогательную таблицу applicant,  куда включить id образовательной программы, id абитуриента, сумму баллов 
абитуриентов (столбец itog) в отсортированном сначала по id образовательной программы, а потом по убыванию суммы баллов
 виде (использовать запрос из предыдущего урока)*/
CREATE TABLE applicant AS
SELECT program_id, enrollee.enrollee_id, SUM(result) AS itog
FROM enrollee
     JOIN program_enrollee USING(enrollee_id)
     JOIN program USING(program_id)
     JOIN program_subject USING(program_id)
     JOIN subject USING(subject_id)
     JOIN enrollee_subject USING(enrollee_id, subject_id)
WHERE enrollee_subject.enrollee_id = enrollee.enrollee_id
GROUP BY program_id, enrollee_id
ORDER BY program_id, itog DESC;

SELECT * FROM applicant;
+------------+-------------+------+
| program_id | enrollee_id | itog |
+------------+-------------+------+
| 1          | 3           | 230  |
| 1          | 2           | 226  |
| 1          | 1           | 213  |
| 2          | 6           | 276  |
| 2          | 3           | 230  |
| 2          | 2           | 226  |
| 3          | 6           | 270  |
| 3          | 4           | 238  |
| 3          | 5           | 192  |
| 3          | 1           | 179  |
| 4          | 6           | 270  |
| 4          | 3           | 242  |
| 4          | 5           | 192  |
| 4          | 1           | 179  |
+------------+-------------+------+

/*Из таблицы applicant, созданной на предыдущем шаге, удалить записи, если абитуриент на выбранную образовательную 
программу не набрал минимального балла хотя бы по одному предмету (использовать запрос из предыдущего урока).*/
DELETE FROM applicant
WHERE (program_id, enrollee_id) IN(
    SELECT DISTINCT program.program_id, enrollee.enrollee_id
    FROM enrollee
        INNER JOIN program_enrollee ON program_enrollee.enrollee_id = enrollee.enrollee_id
        INNER JOIN program ON program.program_id = program_enrollee.program_id
        INNER JOIN program_subject ON program_subject.program_id = program.program_id
        INNER JOIN subject ON subject.subject_id = program_subject.subject_id
        INNER JOIN enrollee_subject ON enrollee_subject.subject_id = subject.subject_id
        and enrollee_subject.enrollee_id = enrollee.enrollee_id
    WHERE result < min_result
    );

SELECT * FROM applicant;
+------------+-------------+------+
| program_id | enrollee_id | itog |
+------------+-------------+------+
| 1          | 3           | 230  |
| 1          | 2           | 226  |
| 1          | 1           | 213  |
| 2          | 6           | 276  |
| 2          | 3           | 230  |
| 2          | 2           | 226  |
| 3          | 6           | 270  |
| 3          | 4           | 238  |
| 3          | 5           | 192  |
| 4          | 6           | 270  |
| 4          | 3           | 242  |
| 4          | 5           | 192  |
+------------+-------------+------+

/*Повысить итоговые баллы абитуриентов в таблице applicant на значения дополнительных баллов (использовать запрос из предыдущего урока).*/
UPDATE applicant
    INNER JOIN (    
    SELECT enrollee.enrollee_id, IF(SUM(bonus) IS Null, 0, SUM(bonus)) AS Бонус
    FROM enrollee
        LEFT JOIN enrollee_achievement ON enrollee_achievement.enrollee_id = enrollee.enrollee_id
        LEFT JOIN achievement ON achievement.achievement_id = enrollee_achievement.achievement_id
    GROUP BY enrollee_id
                ) zapros ON applicant.enrollee_id = zapros.enrollee_id
SET itog = itog + zapros.Бонус;

SELECT * FROM applicant;
+------------+-------------+------+
| program_id | enrollee_id | itog |
+------------+-------------+------+
| 1          | 3           | 235  |
| 1          | 2           | 226  |
| 1          | 1           | 219  |
| 2          | 6           | 276  |
| 2          | 3           | 235  |
| 2          | 2           | 226  |
| 3          | 6           | 270  |
| 3          | 4           | 239  |
| 3          | 5           | 200  |
| 4          | 6           | 270  |
| 4          | 3           | 247  |
| 4          | 5           | 200  |
+------------+-------------+------+

/*Поскольку при добавлении дополнительных баллов, абитуриенты по каждой образовательной программе могут следовать не в 
порядке убывания суммарных баллов, необходимо создать новую таблицу applicant_order на основе таблицы applicant. При
 создании таблицы данные нужно отсортировать сначала по id образовательной программы, потом по убыванию итогового балла.
  А таблицу applicant, которая была создана как вспомогательная, необходимо удалить.*/
CREATE TABLE applicant_order AS
    (
    SELECT program_id, enrollee_id, itog
    FROM applicant
    ORDER BY program_id, itog DESC
     );
        
DROP TABLE applicant;
+------------+-------------+------+
| program_id | enrollee_id | itog |
+------------+-------------+------+
| 1          | 3           | 235  |
| 1          | 2           | 226  |
| 1          | 1           | 219  |
| 2          | 6           | 276  |
| 2          | 3           | 235  |
| 2          | 2           | 226  |
| 3          | 6           | 270  |
| 3          | 4           | 239  |
| 3          | 5           | 200  |
| 4          | 6           | 270  |
| 4          | 3           | 247  |
| 4          | 5           | 200  |
+------------+-------------+------+

/*Включить в таблицу applicant_order новый столбец str_id целого типа , расположить его перед первым.*/
ALTER TABLE applicant_order ADD str_id INT FIRST;

SELECT * FROM applicant_order;
+--------+------------+-------------+------+
| str_id | program_id | enrollee_id | itog |
+--------+------------+-------------+------+
| NULL   | 1          | 3           | 235  |
| NULL   | 1          | 2           | 226  |
| NULL   | 1          | 1           | 219  |
| NULL   | 2          | 6           | 276  |
| NULL   | 2          | 3           | 235  |
| NULL   | 2          | 2           | 226  |
| NULL   | 3          | 6           | 270  |
| NULL   | 3          | 4           | 239  |
| NULL   | 3          | 5           | 200  |
| NULL   | 4          | 6           | 270  |
| NULL   | 4          | 3           | 247  |
| NULL   | 4          | 5           | 200  |
+--------+------------+-------------+------+

/*Занести в столбец str_id таблицы applicant_order нумерацию абитуриентов, которая начинается с 1 для каждой 
образовательной программы.*/
SET @num_pr := 0;
SET @row_num := 1;

UPDATE applicant_order 
SET str_id = IF(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1 AND @num_pr := @num_pr + 1);

SELECT * FROM applicant_order;
+--------+------------+-------------+------+
| str_id | program_id | enrollee_id | itog |
+--------+------------+-------------+------+
| 1      | 1          | 3           | 235  |
| 2      | 1          | 2           | 226  |
| 3      | 1          | 1           | 219  |
| 1      | 2          | 6           | 276  |
| 2      | 2          | 3           | 235  |
| 3      | 2          | 2           | 226  |
| 1      | 3          | 6           | 270  |
| 2      | 3          | 4           | 239  |
| 3      | 3          | 5           | 200  |
| 1      | 4          | 6           | 270  |
| 2      | 4          | 3           | 247  |
| 3      | 4          | 5           | 200  |
+--------+------------+-------------+------+

/*Создать таблицу student,  в которую включить абитуриентов, которые могут быть рекомендованы к зачислению  в 
соответствии с планом набора. Информацию отсортировать сначала в алфавитном порядке по названию программ, а потом 
по убыванию итогового балла.*/
CREATE TABLE student AS
SELECT program.name_program, enrollee.name_enrollee, applicant_order.itog
FROM program
    INNER JOIN applicant_order ON applicant_order.program_id = program.program_id
    INNER JOIN enrollee ON enrollee.enrollee_id = applicant_order.enrollee_id
WHERE applicant_order.str_id <= program.plan 
ORDER BY name_program, itog DESC;

SELECT * FROM student;
+-------------------------------------+-----------------+------+
| name_program                        | name_enrollee   | itog |
+-------------------------------------+-----------------+------+
| Математика и компьютерные науки     | Степанова Дарья | 276  |
| Мехатроника и робототехника         | Степанова Дарья | 270  |
| Мехатроника и робототехника         | Семенов Иван    | 247  |
| Мехатроника и робототехника         | Попов Илья      | 200  |
| Прикладная математика и информатика | Семенов Иван    | 235  |
| Прикладная математика и информатика | Абрамова Катя   | 226  |
| Прикладная механика                 | Степанова Дарья | 270  |
| Прикладная механика                 | Яковлева Галина | 239  |
+-------------------------------------+-----------------+------+

/*Придумайте один или несколько запросов корректировки данных
Внести дополнительный столбец achievement, в таблицу applicant_order. Занести название достижения, которую имеет студент. Если достижений у абитуриента нет, вывести - "Достижений нет"*/
ALTER TABLE applicant_order ADD COLUMN achievement VARCHAR(50);

UPDATE applicant_order
INNER JOIN (
    SELECT enrollee_id, GROUP_CONCAT(DISTINCT name_achievement SEPARATOR ', ') AS name_achievement       FROM enrollee
       LEFT JOIN 
    (
        SELECT enrollee_id, name_achievement 
        FROM enrollee_achievement 
        INNER JOIN achievement USING(achievement_id)
    ) quest USING(enrollee_id)
    GROUP BY enrollee_id
    ) q1 USING(enrollee_id)
SET achievement = COALESCE(name_achievement, 'Достижений нет');

SELECT * FROM applicant_order;
+--------+------------+-------------+------+---------------------------------------+
| str_id | program_id | enrollee_id | itog | achievement                           |
+--------+------------+-------------+------+---------------------------------------+
| 1      | 1          | 3           | 235  | Золотая медаль                        |
| 2      | 1          | 2           | 226  | Достижений нет                        |
| 3      | 1          | 1           | 219  | Золотой значок ГТО, Серебряная медаль |
| 1      | 2          | 6           | 276  | Достижений нет                        |
| 2      | 2          | 3           | 235  | Золотая медаль                        |
| 3      | 2          | 2           | 226  | Достижений нет                        |
| 1      | 3          | 6           | 270  | Достижений нет                        |
| 2      | 3          | 4           | 239  | Серебряный значок ГТО                 |
| 3      | 3          | 5           | 200  | Золотая медаль, Золотой значок ГТО    |
| 1      | 4          | 6           | 270  | Достижений нет                        |
| 2      | 4          | 3           | 247  | Золотая медаль                        |
| 3      | 4          | 5           | 200  | Золотая медаль, Золотой значок ГТО    |
+--------+------------+-------------+------+---------------------------------------+

================================================
/*3.5 База данных "Учебная аналитика по курсу"*/
================================================

/*Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные запросы). 
Указать к какому уроку и модулю они относятся. Для этого вывести 3 поля:
-в поле Модуль указать номер модуля и его название через пробел;
-в поле Урок указать номер модуля, порядковый номер урока (lesson_position) через точку и название урока через пробел;
-в поле Шаг указать номер модуля, порядковый номер урока (lesson_position) через точку, порядковый номер шага (step_position) 
через точку и название шага через пробел.
Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце (16 символов
 - это номер модуля или урока, пробел и  название Урока или Модуля к ним присоединить "..."). Информацию отсортировать по возрастанию 
 номеров модулей, порядковых номеров уроков и порядковых номеров шагов.*/
SELECT CONCAT(module.module_id, ' ', LEFT(module_name, 14), '...') AS Модуль,
    CONCAT(module.module_id, '.', lesson_position, ' ', LEFT(lesson_name, 12), '...') AS Урок,
    CONCAT(module.module_id, '.', lesson_position, '.', step_position, ' ', step_name) AS Шаг
FROM step
    INNER JOIN lesson ON lesson.lesson_id = step.lesson_id
    INNER JOIN module ON module.module_id = lesson.module_id
WHERE step_name LIKE '%Вложен%запрос%'
ORDER BY Модуль, Урок, Шаг;
+---------------------+---------------------+-------------------------------------------------------------+
| Модуль              | Урок                | Шаг                                                         |
+---------------------+---------------------+-------------------------------------------------------------+
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.2 Вложенный запрос, возвращающий одно значение          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.3 Использование вложенного запроса в выражении          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.4 Вложенный запрос, оператор IN                         |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.5 Вложенный запрос, операторы ANY и ALL                 |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.6 Вложенный запрос после SELECT                         |
| 1 Основы реляцио... | 1.5 Запросы корр... | 1.5.5 Добавление записей, вложенные запросы                 |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.7 Запросы для нескольких таблиц со вложенными запросами |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.8 Вложенные запросы в операторах соединения             |
| 2 Запросы SQL к ... | 2.3 Запросы корр... | 2.3.5 Запрос на обновление, вложенные запросы               |
+---------------------+---------------------+-------------------------------------------------------------+

/*Заполнить таблицу step_keyword следующим образом: если ключевое слово есть в названии шага, то включить в step_keyword 
строку с id шага и id ключевого слова. */
INSERT INTO step_keyword (step_id, keyword_id)
    SELECT step_id, keyword_id
    FROM keyword CROSS JOIN step
    WHERE regexp_instr(step_name, concat('\\b', keyword_name, '\\b'));

SELECT * FROM step_keyword;
+---------+------------+
| step_id | keyword_id |
+---------+------------+
| 38      | 1          |
| 81      | 3          |
| 82      | 4          |
| 82      | 5          |
| 82      | 6          |
| 81      | 7          |
| 82      | 7          |
| 83      | 7          |
| 83      | 8          |
| 47      | 10         |
| 47      | 11         |
| 42      | 15         |
| 43      | 16         |
| 44      | 16         |
| 42      | 17         |
| 43      | 18         |
| 46      | 18         |
| 43      | 19         |
| 88      | 26         |
| 112     | 27         |
| 113     | 27         |
| 37      | 28         |
| 37      | 29         |
| 18      | 30         |
| 36      | 30         |
| 19      | 31         |
| 18      | 32         |
+---------+------------+

/*Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова MAX и AVG одновременно. Для шагов 
указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед заголовком - пробел.
 Позицию шага в уроке вывести в виде двух цифр (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать 
 Шаг. Информацию отсортировать по первому столбцу в алфавитном порядке.*/
SELECT CONCAT(module.module_id, '.', lesson_position, '.', LPAD(step_position, 2, '0'), ' ', step_name) AS Шаг
FROM module
    INNER JOIN lesson USING(module_id)
    INNER JOIN step USING(lesson_id)
    INNER JOIN step_keyword USING(step_id)
    INNER JOIN keyword USING(keyword_id)
WHERE keyword_name='MAX' OR 'AVG'
ORDER BY 1;
+---------------------------------------------------------+
| Шаг                                                     |
+---------------------------------------------------------+
| 1.3.04 Выборка данных, групповые функции MIN, MAX и AVG |
| 1.4.06 Вложенный запрос после SELECT                    |
+---------------------------------------------------------+



